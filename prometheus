package com.example.prometheus;

import java.util.Set;

import org.openrewrite.ExecutionContext;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.recipe.Recipe;

/**
 * *.build(name, help)  →  *.builder().name(name).help(help)
 * Handles imported, fully-qualified, and statically-imported usages.
 */
public class ReplaceStaticBuildWithBuilder extends Recipe {

    @Override
    public String getDisplayName() {
        return "Prometheus metrics: replace static build() with builder()";
    }

    /* metric simple names we care about */
    private static final Set<String> METRICS =
            Set.of("Counter", "Gauge", "Histogram", "Summary");

    /* overloads we must catch */
    private static final MethodMatcher BUILD_0ARGS =
            new MethodMatcher("* build()");
    private static final MethodMatcher BUILD_2ARGS =
            new MethodMatcher("* build(java.lang.String, java.lang.String)");

    @Override
    public JavaIsoVisitor<ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<>() {

            /* template for the (String,String) convenience overload */
            private final JavaTemplate twoArgTemplate = JavaTemplate.builder(
                    this::getCursor,
                    "#{any()}.builder()" +
                    ".name(#{any(java.lang.String)})" +
                    ".help(#{any(java.lang.String)})")
                .imports("io.prometheus.metrics.core.metrics.*")
                .build();

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation mi,
                                                             ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(mi, ctx);

                /*
                 * 1. -------------------------- metric match? --------------------------
                 *    fully-qualified     → select = FieldAccess
                 *    normal import       → select = Identifier
                 *    static import       → select = null
                 */
                boolean hasSelect   = m.getSelect() != null;
                boolean metricMatch = hasSelect
                        ? METRICS.contains(simpleName(m.getSelect()))
                        : isMetricDeclaration(m);   // static import case

                if (!metricMatch) {
                    return m;
                }

                /*
                 * 2. -------------------------- two-arg overload ----------------------
                 */
                if (BUILD_2ARGS.matches(m)) {
                    return m.withTemplate(twoArgTemplate,
                            m.getCoordinates().replace(),
                            // #{any()} is the metric class: Counter, Gauge, …
                            hasSelect ? m.getSelect() : metricIdentifier(m),
                            // the existing arguments go into name(…)/help(…)
                            m.getArguments().get(0),
                            m.getArguments().get(1));
                }

                /*
                 * 3. -------------------------- zero-arg overload ---------------------
                 *    We need a template whose *text* contains the metric type because
                 *    #{any()} cannot appear without a preceding expression.
                 */
                if (BUILD_0ARGS.matches(m)) {
                    String metric = hasSelect
                            ? simpleName(m.getSelect())
                            : simpleName(metricIdentifier(m));

                    JavaTemplate zeroArgTemplate = JavaTemplate.builder(
                                this::getCursor,
                                metric + ".builder()")
                            .imports("io.prometheus.metrics.core.metrics." + metric)
                            .build();

                    return m.withTemplate(
                            zeroArgTemplate,
                            m.getCoordinates().replace());
                }

                return m;
            }

            /* --------------------------------------------------------------------- */

            /** Extract right-most identifier from Identifier or FieldAccess. */
            private static String simpleName(J expr) {
                return expr instanceof J.FieldAccess fa ? fa.getSimpleName()
                     : expr instanceof J.Identifier   id ? id.getSimpleName()
                     : "";
            }

            /**
             * When the call is statically imported (`build(...)`) the selector is null.
             * We recover the metric class from the method’s declaring type.
             */
            private static boolean isMetricDeclaration(J.MethodInvocation m) {
                return m.getMethodType() != null
                        && m.getMethodType().getDeclaringType() instanceof JavaType.FullyQualified fq
                        && METRICS.contains(fq.getClassName());
            }

            /**
             * Create a *parsed* identifier for the metric class so templates compile.
             */
            private J metricIdentifier(J.MethodInvocation m) {
                String simple = ((JavaType.FullyQualified)
                        m.getMethodType().getDeclaringType()).getClassName();

                return JavaTemplate.parse(
                        // expression template – just the simple name
                        simple,
                        this::getCursor,
                        getJavaParser(),  // inherited helper
                        ctx -> {})        // no extra imports
                        .get(0)           // first statement
                        .getStatements()
                        .get(0)
                        .withPrefix(m.getPrefix());   // keep original spacing
            }
        };
    }
}
