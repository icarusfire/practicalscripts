type: specs.openrewrite.org/v1beta/recipe
name: com.example.prometheus.MigrateSimpleclientToMetrics
displayName: Migrate Prometheus simpleclient → prometheus-metrics
description: >
  Full mechanical migration: moves classes, renames labels(..),
  converts build(..) chains, removes create(), and replaces *.Child types.

recipeList:
  # ────────────────── package / type moves ──────────────────
  - org.openrewrite.java.ChangeType:
      oldFullyQualifiedTypeName: io.prometheus.client.Counter
      newFullyQualifiedTypeName: io.prometheus.metrics.core.metrics.Counter
  - org.openrewrite.java.ChangeType:
      oldFullyQualifiedTypeName: io.prometheus.client.Histogram
      newFullyQualifiedTypeName: io.prometheus.metrics.core.metrics.Histogram
  - org.openrewrite.java.ChangeType:
      oldFullyQualifiedTypeName: io.prometheus.client.Summary
      newFullyQualifiedTypeName: io.prometheus.metrics.core.metrics.Summary
  - org.openrewrite.java.ChangeType:
      oldFullyQualifiedTypeName: io.prometheus.client.CollectorRegistry
      newFullyQualifiedTypeName: io.prometheus.metrics.model.registry.PrometheusRegistry

  # ────────────────── method rename ─────────────────────────
  - org.openrewrite.java.ChangeMethodName:
      methodPattern: "io.prometheus.metrics.core.metrics..* labels(..)"
      newMethodName: labelValues

  # ────────────────── custom visitors ───────────────────────
  - com.example.prometheus.ReplaceStaticBuildWithBuilder
  - com.example.prometheus.RemoveCreateCalls
  - com.example.prometheus.ReplaceChildTypes


-------------------------


package com.example.prometheus;

import java.util.Set;

import org.openrewrite.ExecutionContext;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.recipe.Recipe;

package com.example.prometheus;

/*
 * ────────────────────────────────────────────────────────────────────────────────
 *  ReplaceStaticBuildWithBuilder
 *
 *  Goal
 *  ─────
 *  Convert legacy calls such as
 *
 *      Counter.build("name", "help")
 *
 *  into the fluent builder style required by prometheus-metrics 1.x:
 *
 *      Counter.builder().name("name").help("help")
 *
 *  Why do this in a custom Recipe?
 *  • The official ChangeMethodSignature recipe cannot describe this pattern.
 *  • We must preserve comments, formatting, and imports automatically.
 *
 *  How OpenRewrite applies it:
 *  1.  The Maven / Gradle plugin discovers this class on the classpath.
 *  2.  The framework asks `getVisitor()` for a JavaVisitor instance.
 *  3.  The visitor walks every Java file; when `visitMethodInvocation` hits a
 *      matching `build(..)`, it swaps that node for a new template.
 *  4.  At the end of the run, OpenRewrite’s import manager inserts any missing
 *      imports and removes unused ones.
 * ────────────────────────────────────────────────────────────────────────────────
 */

import java.util.Set;

import org.openrewrite.ExecutionContext;          // Carries shared runtime data
import org.openrewrite.java.JavaVisitor;           // Core AST walker
import org.openrewrite.java.JavaTemplate;          // Snippet generator with #{placeholders}
import org.openrewrite.java.tree.J;                // All Java AST node types
import org.openrewrite.recipe.Recipe;              // Base class for every custom recipe

public class ReplaceStaticBuildWithBuilder extends Recipe {

    /* ────────────────────────────────────────────────────────────────────────
     *  Required Recipe metadata
     * ────────────────────────────────────────────────────────────────────────
     */

    @Override
    public String getDisplayName() {                // Shown by CLI / IDE
        return "Counter.build(name, help) → Counter.builder().name(name).help(help)";
    }

    @Override
    public String getDescription() {                // One-liner in reports
        return "Replaces obsolete static build(Name, Help) factory with the "
             + "prometheus-metrics builder pattern.";
    }

    /* ────────────────────────────────────────────────────────────────────────
     *  Visitor factory
     *  OpenRewrite creates *one* visitor instance per compilation unit.
     * ────────────────────────────────────────────────────────────────────────
     */
    @Override
    public JavaVisitor<ExecutionContext> getVisitor() {
        return new JavaVisitor<>() {

            /* ----------------------------------------------------------------
             * 1.  Simple-name whitelist
             *     Using only the simple name (Counter, Gauge…) avoids problems
             *     with ChangeType execution order: the package may have been
             *     swapped already or not yet, but the simple name stays.
             * ----------------------------------------------------------------
             */
            private final Set<String> METRIC_SIMPLE_NAMES =
                Set.of("Counter", "Gauge", "Histogram", "Summary");

            /* ----------------------------------------------------------------
             * 2.  JavaTemplate
             *     Think “code stencil”.  The string inside looks like normal
             *     Java but contains #{placeholders}.  At rewrite time those
             *     placeholders are replaced with actual AST nodes.
             *
             *     • getCursor() gives context so the template inherits current
             *       indent, formatting, and import style.
             *     • .imports(..) hints to the import manager that we might need
             *       `io.prometheus.metrics.core.metrics.*`; unused imports are
             *       discarded automatically.
             * ----------------------------------------------------------------
             */
            private final JavaTemplate TEMPLATE = JavaTemplate.builder(this::getCursor,
                    "#{any(java.lang.Class)}.builder()"
                  + ".name(#{any(java.lang.String)})"
                  + ".help(#{any(java.lang.String)})")
                  .imports("io.prometheus.metrics.core.metrics.*")
                  .build();

            /* ----------------------------------------------------------------
             * 3.  visitMethodInvocation
             *     Runs for *every* method call in the file.
             * ----------------------------------------------------------------
             */
            @Override
            public J visitMethodInvocation(J.MethodInvocation mi, ExecutionContext ctx) {

                // First, traverse children so nested calls are handled.
                mi = (J.MethodInvocation) super.visitMethodInvocation(mi, ctx);

                /* ------------------------------------------------------------
                 * 3a.  Decide whether this node matches our pattern
                 *      • method name == "build"
                 *      • exactly 2 arguments
                 *      • the thing on the left (select) is an Identifier with
                 *        simple name Counter / Gauge / Histogram / Summary
                 * ------------------------------------------------------------
                 */
                if ("build".equals(mi.getSimpleName())
                        && mi.getArguments().size() == 2
                        && mi.getSelect() instanceof J.Identifier id
                        && METRIC_SIMPLE_NAMES.contains(id.getSimpleName())) {

                    /* --------------------------------------------------------
                     * 3b.  Replace the old node with TEMPLATE output.
                     *
                     *      Coordinates:
                     *      mi.getCoordinates().replace() tells OpenRewrite
                     *      “swap *exactly this* tree node”.
                     *
                     *      Template parameters are passed in the order their
                     *      #{placeholders} appear:
                     *          1. #{any(java.lang.Class)}    → mi.getSelect()
                     *          2. #{any(java.lang.String)}   → argument 0
                     *          3. #{any(java.lang.String)}   → argument 1
                     * --------------------------------------------------------
                     */
                    return mi.withTemplate(
                            TEMPLATE,
                            mi.getCoordinates().replace(),
                            mi.getSelect(),           // Counter / Gauge / …
                            mi.getArguments().get(0), // metric name
                            mi.getArguments().get(1)  // help text
                    );
                }

                // Not a match → leave node unchanged
                return mi;
            }
        };
    }
}

-----------


package com.example.prometheus;

import org.openrewrite.ExecutionContext;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.recipe.Recipe;

/** Drops the now-obsolete `.create()` at the end of metric builder chains. */
public class RemoveCreateCalls extends Recipe {

    @Override
    public String getDisplayName() {
        return "Remove *.create() from metric builder chains";
    }

    @Override
    public JavaIsoVisitor<ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation mi, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(mi, ctx);
                return ("create".equals(m.getSimpleName()) && m.getArguments().isEmpty())
                       ? (J.MethodInvocation) m.getSelect()   // just drop the '.create()'
                       : m;
            }
        };
    }
}


----------------


package com.example.prometheus;

import java.util.Map;

import org.openrewrite.ExecutionContext;
import org.openrewrite.java.ChangeType;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.recipe.Recipe;

/**
 * Replaces Counter.Child, Summary.Child, Histogram.Child → their parent types.
 * Using ChangeType internally keeps imports tidy.
 */
public class ReplaceChildTypes extends Recipe {

    @Override
    public String getDisplayName() {
        return "Replace Prometheus *.Child types with parent metric types";
    }

    @Override
    public JavaIsoVisitor<ExecutionContext> getVisitor() {

        Map<String, String> mapping = Map.of(
            "io.prometheus.client.Counter$Child",   "io.prometheus.metrics.core.metrics.Counter",
            "io.prometheus.client.Summary$Child",  "io.prometheus.metrics.core.metrics.Summary",
            "io.prometheus.client.Histogram$Child","io.prometheus.metrics.core.metrics.Histogram"
        );

        return new JavaIsoVisitor<>() {
            @Override
            public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations v, ExecutionContext ctx) {
                for (Map.Entry<String, String> e : mapping.entrySet()) {
                    doAfterVisit(new ChangeType(e.getKey(), e.getValue(), false));
                }
                return super.visitVariableDeclarations(v, ctx);
            }
        };
    }
}


root pom


<!-- ── ①  OpenRewrite versions (anywhere inside <properties>) ────────── -->
<properties>
    …
    <openrewrite.api.version>7.29.0</openrewrite.api.version>
    <openrewrite.plugin.version>5.29.0</openrewrite.plugin.version>
</properties>

<!-- ── ②  Register the new recipes module (inside <modules>) ─────────── -->
<modules>
    …
    <module>prometheus-migration-recipes</module>
</modules>

<!-- ── ③  Make the plugin (plus recipes JAR) available to every child ── -->
<build>
  <pluginManagement>
    <plugins>
      <plugin>
        <groupId>org.openrewrite.maven</groupId>
        <artifactId>rewrite-maven-plugin</artifactId>
        <version>${openrewrite.plugin.version}</version>

        <!-- Provide the recipes JAR to the plugin class-path -->
        <dependencies>
          <dependency>
            <groupId>com.example</groupId>                 <!-- adjust -->
            <artifactId>prometheus-migration-recipes</artifactId>
            <version>${project.version}</version>          <!-- same as parent -->
          </dependency>
        </dependencies>
      </plugin>
    </plugins>
  </pluginManagement>
</build>

---------------------



new pom

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>com.example</groupId>            <!-- same as parent pom -->
    <artifactId>parent</artifactId>           <!-- parent’s <artifactId> -->
    <version>1.0-SNAPSHOT</version>
  </parent>

  <artifactId>prometheus-migration-recipes</artifactId>
  <packaging>jar</packaging>

  <!-- compile-time only: not shipped with your app -->
  <dependencies>
    <dependency>
      <groupId>org.openrewrite</groupId>
      <artifactId>rewrite-java</artifactId>
      <version>${openrewrite.api.version}</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>

  <!-- keep rewrite.yml inside the jar -->
  <build>
    <resources>
      <resource>
        <directory>${project.basedir}</directory>
        <includes>
          <include>rewrite.yml</include>
        </includes>
      </resource>
    </resources>
  </build>
</project>





-------------------------------------

inside modules:

<plugin>
  <groupId>org.openrewrite.maven</groupId>
  <artifactId>rewrite-maven-plugin</artifactId>

  <!-- run after compilation so the plugin can load the recipes -->
  <executions>
    <execution>
      <id>run-openrewrite</id>
      <phase>process-classes</phase>
      <goals><goal>run</goal></goals>
    </execution>
  </executions>

  <configuration>
    <activeRecipes>
      <recipe>com.example.prometheus.MigrateSimpleclientToMetrics</recipe>
    </activeRecipes>
  </configuration>

  <!-- plugin-only dependency on the recipes JAR -->
  <dependencies>
    <dependency>
      <groupId>com.example</groupId>
      <artifactId>prometheus-migration-recipes</artifactId>
      <version>${project.version}</version>
    </dependency>
  </dependencies>
</plugin>

--


